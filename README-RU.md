[![Build Status](https://github.com/Maslinin/Consyzer/workflows/Build/badge.svg)](https://github.com/Maslinin/Consyzer/actions/workflows/build.yml) [![Quality Gate Status](https://sonarcloud.io/api/project_badges/measure?project=Maslinin_Consyzer&metric=alert_status)](https://sonarcloud.io/summary/new_code?id=Maslinin_Consyzer) [![Coverage](https://sonarcloud.io/api/project_badges/measure?project=Maslinin_Consyzer&metric=coverage)](https://sonarcloud.io/summary/new_code?id=Maslinin_Consyzer) [![GitHub license](https://badgen.net/github/license/Maslinin/Consyzer)](https://github.com/Maslinin/Consyzer/blob/master/LICENSE)

## Обзор
**Consyzer** — это CLI-утилита, созданная для предотвращения проблем консистентности CIL-модулей при использовании механизмов P/Invoke для вызова методов, реализованных вне управляемой среды CLR.

## Для чего?
При разработке CIL-приложений нередко возникают ситуации, требующие обращения к методам, реализованным вне управляемой экосистемы .NET. В исходном коде CIL-модуля такие вызовы описываются атрибутами **DllImport** или **LibraryImport** и сохраняются в метаданных модуля после его сборки, указывая, к какой именно неуправляемой (нативной) библиотеке следует обратиться во время выполнения и какая функция из нее должна быть вызвана.

Ключевой особенностью подобных вызовов является то,
что код функции, вызываемой из неуправляемой библиотеки, не компонуется с исходным кодом CIL-модуля напрямую;
вместо этого в метаданных модуля сохраняется информация о вызываемой функции, включая ссылку на ожидаемое местоположение неуправляемой библиотеки, содержащей реализацию этой функции, в системе.

```csharp
// В данном примере "foo.dll" является ссылкой на неуправляемую библиотеку, содержащую реализацию функции HelloWorld:
[DllImport("foo.dll")]
static extern void HelloWorld();

// или

[LibraryImport("foo.dll")]
static partial void HelloWorld();
```

Приложение функционирует корректно, не нарушая целостность и безопасность системы, когда все неуправляемые библиотеки находятся на местах, описанных в метаданных;
однако, если хотя бы одна из библиотек отсутствует, приложение не только завершит свою работу аварийно, но и может привести к нарушению безопасности всей системы.              

Consyzer был разработан для того, чтобы такие ситуации не стали неожиданностью.

## Как это работает?
1. Consyzer отбирает для анализа файлы, опираясь на заданную директорию и шаблон поиска;  
2. Consyzer логгирует и исключает из анализа файлы, не являющиеся сборками ECMA-355;
3. Consyzer логгирует подробную информацию о каждой найденной сборке ECMA-355, вплоть до её хэш-суммы;
4. Consyzer анализирует найденные сборки ECMA-355 на наличие P/Invoke-вызовов;  
5. Consyzer логгирует подробную информацию о каждом обнаруженном методе, вплоть до его сигнатуры;
6. Consyzer возвращает код выхода, указывающий на конкретный результат анализа, что также позволяет осуществлять индивидуальную обработку инцидентов анализа в соответствии с Вашими требованиями.

> Consyzer логгирует каждый из описанных выше этапов.  

## Какую информацию Consyzer логгирует о найденных P/Invoke вызовах?
Если Consyzer обнаружил сборку, содержащую P/Invoke вызовы, он логгирует следующую информацию:
1. Имя метода;
2. Сигнатуру метода;
3. Ожидаемое имя или местоположение неуправляемой библиотеки, содержащей реализацию этой функции, в системе;
4. Флаги атрибута ``DllImport`` или ``LibraryImport``.

Пример лога, содержащего информацию о P/Invoke методах:
```
[0] File: Foo.dll — Found: 1
	[0]
		Method Signature: 'Int32 static .NativeMethods.HelloWorld()'
		DLL Location: 'libfoobar.so'
		DLL Import Flags: 'CallingConventionCDecl'
[1] File: Bar.dll — Found: 2
	[0]
		Method Signature: 'Void static Foo.Tasks.HelloThere(Single)'
		DLL Location: 'phantom.dll'
		DLL Import Flags: 'CallingConventionStdCall'
	[1]
		Method Signature: 'Void static Foo.Tasks.WhatAFunc(Char[], Int32)'
		DLL Location: 'phantom.dll'
		DLL Import Flags: 'CallingConventionStdCall'
```

## Коды возврата
Consyzer возвращает конкретный код выхода в зависимости от того, где были или не были обнаружены нативные библиотеки, указанные в атрибутах P/Invoke:  

| Код | Значение                                                                			|
|-----|-------------------------------------------------------------------------------------|
| -5  | Ни один из найденных файлов не оказался допустимым для анализа          			|
| -4  | В анализируемой директории не найдено ни одного файла по указанному шаблону поиска  |
| -3  | Не был указан шаблон поиска файлов                                          		|
| -2  | Не была указана директория для анализа                                       		|
| -1  | Произошла непредвиденная ошибка во время анализа                        			|
| 0   | Все библиотеки обнаружены в анализируемой директории                    			|
| 1   | Одна или несколько библиотек обнаружены через переменную окружения **PATH** 		|
| 2   | Одна или несколько библиотек обнаружены в системной директории     					|
| 3   | Одна или несколько библиотек обнаружены по абсолютному пути        					|
| 4   | Одна или несколько библиотек обнаружены по относительному пути     					|
| 5   | Одна или несколько библиотек отсутствуют в системе                      			|

> Обратите внимание, что только последний из кодов указывает на нарушение консистентности модуля.
> Если библиотеки были обнаружены в разных местах, возвращается наибольший из соответствующих кодов.  
> Отрицательные коды сигнализируют об ошибках конфигурации или исполнения.

## Как запустить? 
**Consyzer** запускается из командной строки (CLI) и требует два обязательных параметра:
1. Директория, содержащая CIL-модули для анализа;
2. Шаблон поиска файлов, определяющий, какие именно CIL-модули должны быть подвергнуты анализу.

### Общий шаблон запуска
```
Consyzer.exe --AnalysisDirectory <путь_к_директории> --SearchPattern <шаблон_поиска>
```

### Пример
```
Consyzer.exe --AnalysisDirectory C:\Modules --SearchPattern "output.exe, *.dll"
```

## Анализ нескольких проектов в решении
Вы можете использовать [этот](https://github.com/Maslinin/Consyzer/blob/master/DevOps/SolutionAnalyzer.ps1) сценарий *PowerShell* для анализа выходных артефактов всех проектов в решении. 
Этот сценарий может быть также использован в **конвейере CI/CD**.