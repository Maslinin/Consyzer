[![Build Status](https://github.com/Maslinin/Consyzer/workflows/Build/badge.svg)](https://github.com/Maslinin/Consyzer/actions/workflows/build.yml) [![Quality Gate Status](https://sonarcloud.io/api/project_badges/measure?project=Maslinin_Consyzer&metric=alert_status)](https://sonarcloud.io/summary/new_code?id=Maslinin_Consyzer) [![Coverage](https://sonarcloud.io/api/project_badges/measure?project=Maslinin_Consyzer&metric=coverage)](https://sonarcloud.io/summary/new_code?id=Maslinin_Consyzer) [![GitHub license](https://badgen.net/github/license/Maslinin/Consyzer)](https://github.com/Maslinin/Consyzer/blob/master/LICENSE)

## Обзор
**Consyzer** - утилита, созданная для предотвращения проблем консистентности CIL-модулей при вызове внешних функций из неуправляемых библиотек динамической компоновки (DLLs).

Представим сценарий, где в исходном коде приложения присутствуют вызовы внешних функций из неуправляемых библиотек динамической компоновки (DLLs).
В исходном коде CIL-модуля такие вызовы описываются атрибутом **DllImport** и сохраняются в метаданных приложения после его сборки.

Ключевой особенностью атрибута **DllImport** является то,
что функция, вызываемая из неуправляемой DLL, не компонуется с исходным кодом CIL-модуля напрямую;
вместо этого в метаданных модуля сохраняется информация о такой функции, включая ссылку на ожидаемое местоположение неуправляемой DLL, содержащей определение этой функции, в системе.    

```
//В данном случае "kernel32.dll" является ссылкой к неуправляемой DLL, содержащей определение функции HelloWorld:
[DllImport("kernel32.dll")]
static extern void HelloWorld();
```

Приложение функционирует корректно, не нарушая целостность и безопасность системы, когда все неуправляемые DLL находятся на местах, описанных в метаданных;
однако, если хотя бы одна из DLL отсутствует, приложение не только завершит свою работу аварийно, но и может привести к нарушению безопасности всей системы.              

Для предотвращения инцидентов подобного рода и был разработан Consyzer.

## Как это работает?
1. Consyzer отбирает для анализа файлы, опираясь на заданную для анализа директорию и шаблон поиска;
2. Consyzer отбрасывает файлы, не являющиеся сборками метаданных ECMA-355;
3. Consyzer сканирует отобранные для анализа модули на предмет внешних функций;
4. Consyzer логгирует подробную информацию о каждой обнаруженной внешней функции, вплоть до её сигнатуры;
5. Consyzer в завершение возвращает конкретный код анализа операционной системе, что также позволяет осуществлять индивидуальную обработку каждого из инцидентов анализа в соответствии с Вашими требованиями.

> Consyzer логгирует каждый из указанных выше шагов.

## Какую информацию логгирует Consyzer о внешней функции?
Если Consyzer обнаружил внешнюю функцию, он логгирует следующую информацию о ней:
1. Имя функции;
2. Сигнатуру функции;
3. Ожидаемое местоположение неуправляемой DLL, содержащей определение этой функции, в системе;
4. Аргументы атрибута DllImport.

## Коды возврата
> 0 - все неуправляемые DLL-компоненты, используемые в анализируемых CIL-модулях, существуют в анализируемой директории;      
> 1 - один или несколько неуправляемых DLL-компонентов, используемых в анализируемых CIL-модулях, существуют на указанном в метаданных абсолютном пути;        
> 2 - один или несколько неуправляемых DLL-компонентов, используемых в анализируемых CIL-модулях, существуют на указанном в метаданных относительном пути;        
> 3 - один или несколько неуправляемых DLL-компонентов, используемых в анализируемых CIL-модулях, существуют в указанной в метаданных системной папке;        
> 4 - один или несколько неуправляемых DLL-компонентов, используемых в анализируемых CIL-модулях, отсутствуют на местоположении, указанном в метаданных.         

> Обратите внимание, что только последний из кодов возврата означает о нарушении консистентности CIL-модуля, в то время как остальные коды сообщают об отличном от анализируемой директории расположении неуправляемых DLL-компонентов.

> Если расположение одного из неуправляемых DLL-компонентов соответствует коду возврата 2, а другого коду возврата 3, утилита вернет наибольший из кодов.

## Как запустить? 
Запуск утилиты происходит из CLI. На вход утилите должны быть переданы два обязательных аргумента:
1. Директория, содержащая CIL-модули для анализа;
2. Расширения CIL-модулей, подлежащих анализу.

Пример запуска Consyzer из CLI:
```
C:\Consyzer.exe --AnalysisDirectory C:\analysisDirectory --SearchPattern "output.exe, *.dll"
```

## Анализ нескольких проектов в решении
Вы можете использовать сценарий *PowerShell*, находящийся в ```DevOps\SolutionAnalyzer.ps1``` для анализа выходных артефактов всех проектов в решении. 
Этот сценарий может быть также использован в **конвейере CI/CD**.